// ChatApp.tsx
import React, { useEffect, useState } from 'react';
import styled from 'styled-components';
import { supabase } from '../../api/supabase.api';

// Styled components
const ChatContainer = styled.div`
  display: flex;
  height: 70vh;
`;

const UsersList = styled.aside`
  width: 100px;
  border-right: 1px solid #ccc;
  overflow-y: auto;
`;

const User = styled.div`
  padding: 10px;
  border-bottom: 1px solid #eee;
  &:hover {
    background-color: #f5f5f5;
  }
`;

const MessagesContainer = styled.main`
  flex: 1;
  display: flex;
  flex-direction: column;
`;

const MessageList = styled.div`
  flex-grow: 1;
  overflow-y: auto;
  padding: 20px;
`;

const Message = styled.div`
  margin-bottom: 10px;
  background: #f9f9f9;
  padding: 10px;
  border-radius: 10px;
`;

const InputContainer = styled.div`
  padding: 10px;
  background: #fff;
`;

const Input = styled.input`
  width: 100%;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 5px;
`;

// TypeScript types for messages and users
type MessageType = {
  id: number;
  content: string;
};

type UserType = {
  id: number;
  name: string;
  email:string;
};

// React component
const ChatApp: React.FC = () => {
  const [messages, setMessages] = useState<MessageType[]>([]);
  const [users, setUsers] = useState<UserType[]>([]);
  const [inputValue, setInputValue] = useState('');

  
  useEffect(() => {
    // Fetch initial data
    const fetchUsers = async () => {
      let { data, error } = await supabase.from('profiles').select('*');
      if (error) {
        console.error('Error fetching users:', error);
        return;
      }
      if (data) {
        // You might need to assert the data to UserType[]
        setUsers(data as UserType[]);
      }
    };

  const fetchMessages = async () => {
    let { data, error } = await supabase.from('messages').select('*');
    if (error) {
      console.error('Error fetching messages:', error);
      return;
    }
    if (data) {
      // You might need to assert the data to MessageType[]
      setMessages(data as MessageType[]);
    }
  };

  fetchUsers();
  fetchMessages();
  
  // Real-time subscriptions
  // useEffect 훅 안에 있는 데도 변경시 추적함.
  // Supabase를 이용해 실시간으로 'messages' 테이블에 
//   새 메시지가 추가될 때마다 해당 메시지를 React 컴포넌트의 상태에 추가하는 기능을 구현합니다. 
  const messageChannel = supabase
    .channel('messages_channel')
    .on('postgres_changes', {
      event: 'INSERT',
      schema: 'public',
      table: 'messages',
    }, payload => {
      console.log('payload',payload)
      // Assume payload.new contains the new message
      setMessages(prevMessages => [...prevMessages, payload.new as MessageType]);
    })
    .subscribe();

  // Clean up subscriptions on unmount
  return () => {
    messageChannel.unsubscribe();
  };
}, []);


  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setInputValue(event.target.value);
  };

const handleKeyPress = async(event: React.KeyboardEvent<HTMLInputElement>) => {
  if (event.key === 'Enter' && inputValue.trim()) {
    const { data: { user } } = await supabase.auth.getUser()

    // Supabase로 메시지 보내기
    supabase.from('messages').insert([
      { content: inputValue,  author_id: user?.id }
    ]).then(({ error }) => {
      if (error) {
        console.error('메시지 삽입 중 오류가 발생했습니다:', error);
      }
    });

    setInputValue('');
  }
};

  return (
    <ChatContainer>
      <UsersList>
        {users.map((user) => (
          <User key={user.id}>{user.email}</User>
        ))}
      </UsersList>
      <MessagesContainer>
        <MessageList>
          {messages.map((message) => (
            <Message key={message.id}>{message.content}</Message>
          ))}
        </MessageList>
        <InputContainer>
          <Input
            type="text"
            value={inputValue}
            onChange={handleInputChange}
            onKeyPress={handleKeyPress}
            placeholder="Type your message..."
          />
        </InputContainer>
      </MessagesContainer>
    </ChatContainer>
  );
};

export default ChatApp;

1번 이미지 schema를 전제로 supabase realtime을 구현 중이고, 2번 이미지의 ui를 클릭을 하면 3번 이미지의 ui가 실행이 되고 올린 코드는 3번 이미지의 코드 입니다. 3번 이미지 ui의 유저란은 현재 로그인한 사용자들만 나오도록 하고 싶고 schema 의 chats_users 테이블에서 관리하고 싶습니다 , 사용자들 중에 한명을 클릭을 하면   schema에 나오는 messages테이블에 chat_id를 고유한 값으로 주고  chats 테이블에도 업데이트 되도록 하고 chat_id값을 기반으로 오른쪽 채팅란 채팅을 하면 1:1 대화가 되도록 만들고 싶습니다. 
그리고
채팅방에 대한 Supabase 채널 설정
/** state to store a reference of the realtime channel */
const [channel, setChannel] = useState<RealtimeChannel>();

/** Setup supabase realtime chat channel and subscription */
useEffect(() => {
    /** only create the channel if we have a roomCode and username */
    if (roomCode && username) {
        /**
         * Step 1:
         *
         * Create the supabase channel for the roomCode, configured
         * so the channel receives its own messages
         */
        const channel = supabase.channel(`room:${roomCode}`, {
            config: {
                broadcast: {
                    self: true
                }
            }
        });

        /**
         * Step 2:
         *
         * Listen to broadcast messages with a `message` event
         */
        channel.on('broadcast', { event: 'message' }, ({ payload }) => {
            setMessages((messages) => [...messages, payload]);
        });

        /**
         * Step 3:
         *
         * Subscribe to the channel
         */
        channel.subscribe();

        /**
         * Step 4:
         *
         * Set the channel in the state
         */
        setChannel(channel);

        /**
         * * Step 5:
         *
         * Return a clean-up function that unsubscribes from the channel
         * and clears the channel state
         */
        return () => {
            channel.unsubscribe();
            setChannel(undefined);
        };
    }
}, [roomCode, username]);

onMessage={(message) => {
  setMessages((messages) => {
      return [
          ...messages,
          {
              id: createIdentifier(),
              message,
              username,
              type: 'chat'
          }
      ];
  });
}}


온라인 채팅 사용자 표시
channel.on('presence', { event: 'sync' }, () => {
  /** Get the presence state from the channel, keyed by realtime identifier */
  const presenceState = channel.presenceState();

  /** transform the presence */
  const users = Object.keys(presenceState)
      .map((presenceId) => {
          const presences = presenceState[presenceId] as unknown as { username: string }[];
          return presences.map((presence) => presence.username);
      })
      .flat();
  /** sort and set the users */
  setUsers(users.sort());
});

channel.subscribe((status) => {
  if (status === 'SUBSCRIBED') {
      channel.track({ username });
  }
});

사용자가 채팅방에 참여하고 나갈 때 표시
/**
* Step 1:
*
* Listen to presence event for users joining the chat room
*/
channel.on('presence', { event: 'join' }, ({ newPresences }) => {
 const presenceMsg = newPresences.map(({ username }) => {
   return {
     id: createIdentifier(),
     type: 'presence' as const,
     username,
     message: 'joined' as const
   };
 });
 setMessages((messages) => [...messages, ...presenceMsg]);
});

/**
* Step 2:
*
* Listen to presence event for users leaving the chat room
*/
channel.on('presence', { event: 'leave' }, ({ leftPresences }) => {
 const presenceMsg = leftPresences.map(({ username }) => {
   return {
     id: createIdentifier(),
     type: 'presence' as const,
     username,
     message: 'left' as const
   };
 });
 setMessages((messages) => [...messages, ...presenceMsg]);


const handleKeyPress = async(event: React.KeyboardEvent<HTMLInputElement>) => {
  if (event.key === 'Enter' && inputValue.trim()) {
    const { data: { user } } = await supabase.auth.getUser()
// console.log('a',user);
//       // Supabase로 메시지 보내기
    supabase.from('messages').insert([
      { content: inputValue, chat_id: roomCode, author_id: user?.id }
    ]).then(({ error }) => {
      if (error) {
        console.error('메시지 삽입 중 오류가 발생했습니다:', error);
      }
    });

    setInputValue('');
  }
}; 이  코드를 참고해서 처음 올린 내용 1번 이미지 schema를 전제로 supabase realtime을 구현 중이고, 2번 이미지의 ui를 클릭을 하면 3번 이미지의 ui가 실행이 되고 올린 코드는 3번 이미지의 코드 입니다. 3번 이미지 ui의 유저란은 현재 로그인한 사용자들만 나오도록 하고 싶고 schema 의 chats_users 테이블에서 관리하고 싶습니다 , 사용자들 중에 한명을 클릭을 하면   schema에 나오는 messages테이블에 chat_id를 고유한 값으로 주고  chats 테이블에도 업데이트 되도록 하고 chat_id값을 기반으로 오른쪽 채팅란 채팅을 하면 1:1 대화가 되도록 만들고 싶습니다.  



  const [isChatOpen, setChatOpen] = useState(false);

  const openChat = () => setChatOpen(true);
  const closeChat = () => setChatOpen(false);

